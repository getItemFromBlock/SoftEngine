#version 450

layout(local_size_x = 64) in;

struct ParticleData {
    vec4 position;  
    vec4 velocity;  
    vec4 color;     
    vec4 padding;   
};

struct InstanceData {
    vec4 position;
    vec4 color;
};

layout(set = 0, binding = 0) buffer Particles {
    ParticleData particles[];
};

layout(set = 0, binding = 1) buffer Instances {
    InstanceData instances[];
};

layout(push_constant) uniform Push {
    float deltaTime;
    uint  count;
} pc;

const vec3 GRAVITY = vec3(0.0, -9.81, 0.0);
const float DRAG = 0.08;
const vec3 BOUNDS_MIN = vec3(-50.0, -50.0, -50.0);
const vec3 BOUNDS_MAX = vec3(50.0, 50.0, 50.0);
const float BOUNCE_DAMPING = 0.65;

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= pc.count) return;

    vec3 p = particles[id].position.xyz;
    vec3 v = particles[id].velocity.xyz;

    v += GRAVITY * pc.deltaTime;
    v *= 1.0 / (1.0 + DRAG * pc.deltaTime);
    p += v * pc.deltaTime;

    if (p.x < BOUNDS_MIN.x) { p.x = BOUNDS_MIN.x; v.x = -v.x * BOUNCE_DAMPING; }
    if (p.x > BOUNDS_MAX.x) { p.x = BOUNDS_MAX.x; v.x = -v.x * BOUNCE_DAMPING; }
    if (p.y < BOUNDS_MIN.y) { p.y = BOUNDS_MIN.y; v.y = -v.y * BOUNCE_DAMPING; }
    if (p.y > BOUNDS_MAX.y) { p.y = BOUNDS_MAX.y; v.y = -v.y * BOUNCE_DAMPING; }
    if (p.z < BOUNDS_MIN.z) { p.z = BOUNDS_MIN.z; v.z = -v.z * BOUNCE_DAMPING; }
    if (p.z > BOUNDS_MAX.z) { p.z = BOUNDS_MAX.z; v.z = -v.z * BOUNCE_DAMPING; }

    particles[id].position = vec4(p, 1.0);
    particles[id].velocity = vec4(v, 0.0);

    instances[id].position = particles[id].position;
    instances[id].color = particles[id].color;
}